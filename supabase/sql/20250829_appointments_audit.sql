-- Appointments table
create table if not exists public.appointments (
  id uuid primary key default gen_random_uuid(),
  patient_id uuid not null references public.patients(id) on delete cascade,
  doctor_id uuid not null references public.profiles(id) on delete cascade,
  scheduled_at timestamptz not null,
  reason text,
  status text not null default 'scheduled', -- scheduled | completed | canceled
  created_at timestamptz not null default now(),
  updated_at timestamptz not null default now()
);

create index if not exists idx_appointments_patient on public.appointments(patient_id);
create index if not exists idx_appointments_doctor on public.appointments(doctor_id);
create index if not exists idx_appointments_scheduled on public.appointments(scheduled_at);

alter table public.appointments enable row level security;

-- RLS: patients can read their own appointments
create policy if not exists appt_select_patient_self
on public.appointments for select
using (
  exists (
    select 1 from public.patients p where p.id = appointments.patient_id and p.user_id = auth.uid()
  )
);

-- RLS: doctors can read their appointments; admins can read all
create policy if not exists appt_select_doctor_admin
on public.appointments for select
using (
  doctor_id = auth.uid() or exists (select 1 from public.profiles pr where pr.id = auth.uid() and pr.role = 'admin')
);

-- RLS: doctors/admins can insert
create policy if not exists appt_insert_doctor_admin
on public.appointments for insert
with check (
  doctor_id = auth.uid() or exists (select 1 from public.profiles pr where pr.id = auth.uid() and pr.role = 'admin')
);

-- RLS: doctors/admins can update
create policy if not exists appt_update_doctor_admin
on public.appointments for update
using (
  doctor_id = auth.uid() or exists (select 1 from public.profiles pr where pr.id = auth.uid() and pr.role = 'admin')
)
with check (
  doctor_id = auth.uid() or exists (select 1 from public.profiles pr where pr.id = auth.uid() and pr.role = 'admin')
);

-- RLS: doctors/admins can delete (cancel)
create policy if not exists appt_delete_doctor_admin
on public.appointments for delete
using (
  doctor_id = auth.uid() or exists (select 1 from public.profiles pr where pr.id = auth.uid() and pr.role = 'admin')
);

-- Generic audit logs
create table if not exists public.audit_logs (
  id bigint generated by default as identity primary key,
  table_name text not null,
  row_id uuid,
  action text not null, -- INSERT | UPDATE | DELETE
  changed_at timestamptz not null default now(),
  actor uuid default auth.uid(),
  old_data jsonb,
  new_data jsonb
);

alter table public.audit_logs enable row level security;

-- Allow inserts for system/trigger context; restrict reads to admins only
create policy if not exists audit_insert_any
on public.audit_logs for insert
with check (true);

create policy if not exists audit_select_admin
on public.audit_logs for select
using (
  exists (select 1 from public.profiles pr where pr.id = auth.uid() and pr.role = 'admin')
);

-- Trigger function to capture changes
create or replace function public.log_row_change()
returns trigger language plpgsql as $$
begin
  if (tg_op = 'INSERT') then
    insert into public.audit_logs(table_name, row_id, action, new_data)
    values (tg_table_name, (new).id, 'INSERT', to_jsonb(new));
    return new;
  elsif (tg_op = 'UPDATE') then
    insert into public.audit_logs(table_name, row_id, action, old_data, new_data)
    values (tg_table_name, (new).id, 'UPDATE', to_jsonb(old), to_jsonb(new));
    return new;
  elsif (tg_op = 'DELETE') then
    insert into public.audit_logs(table_name, row_id, action, old_data)
    values (tg_table_name, (old).id, 'DELETE', to_jsonb(old));
    return old;
  end if;
  return null;
end;
$$;

-- Attach triggers to key tables
DO $$
BEGIN
  IF NOT EXISTS (
    SELECT 1 FROM pg_trigger WHERE tgname = 'trg_log_patients'
  ) THEN
    create trigger trg_log_patients after insert or update or delete on public.patients
    for each row execute function public.log_row_change();
  END IF;
  IF NOT EXISTS (
    SELECT 1 FROM pg_trigger WHERE tgname = 'trg_log_lab_results'
  ) THEN
    create trigger trg_log_lab_results after insert or update or delete on public.lab_results
    for each row execute function public.log_row_change();
  END IF;
  IF NOT EXISTS (
    SELECT 1 FROM pg_trigger WHERE tgname = 'trg_log_prescriptions'
  ) THEN
    create trigger trg_log_prescriptions after insert or update or delete on public.prescriptions
    for each row execute function public.log_row_change();
  END IF;
  IF NOT EXISTS (
    SELECT 1 FROM pg_trigger WHERE tgname = 'trg_log_predictions'
  ) THEN
    create trigger trg_log_predictions after insert or update or delete on public.predictions
    for each row execute function public.log_row_change();
  END IF;
  IF NOT EXISTS (
    SELECT 1 FROM pg_trigger WHERE tgname = 'trg_log_patient_metrics'
  ) THEN
    create trigger trg_log_patient_metrics after insert or update or delete on public.patient_metrics
    for each row execute function public.log_row_change();
  END IF;
  IF NOT EXISTS (
    SELECT 1 FROM pg_trigger WHERE tgname = 'trg_log_appointments'
  ) THEN
    create trigger trg_log_appointments after insert or update or delete on public.appointments
    for each row execute function public.log_row_change();
  END IF;
END$$;
